

# This file was *autogenerated* from the file alleged_hyperelliptic_enum_p2.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_0 = Integer(0)# 0) PARAMETERS — change n to your extension degree
g = _sage_const_3 
d = g + _sage_const_1               # = 4
n = _sage_const_4                   # <— for example, GF(2^3); set this as you like

# 1) SET UP THE FIELD & RING
K = GF(_sage_const_2 **n, 'a')      # your even‐characteristic field
R = PolynomialRing(K, names=('x',)); (x,) = R._first_ngens(1)

# 2) ENUMERATE all monic degree-d polys q(x)
all_q = [q for q in R.polynomials(of_degree=d)
            if q.leading_coefficient() == K(_sage_const_1 )]
print(f"Found {len(all_q)} monic degree-{d} polys (before grouping).")

# 3) BUILD PGL₂(K) — we just take all GL₂ matrices (scalars won't change the mobius action)
GL2 = GL(_sage_const_2 , K)
PGL2 = [M.matrix() for M in GL2]  

# 4) MOBIUS ACTION on degree-d polynomials
def mobius(q, M):
    a,b = M[_sage_const_0 ,_sage_const_0 ], M[_sage_const_0 ,_sage_const_1 ]
    c,d = M[_sage_const_1 ,_sage_const_0 ], M[_sage_const_1 ,_sage_const_1 ]
    # q((a x + b)/(c x + d)) · (c x + d)^d  clears denominators
    # print(q, q((a*x + b)/(c*x + d)))
    f = q((a*x + b)/(c*x + d)) * (c*x + d)**q.degree()
    # numerator() returns the polynomial, monic() normalizes leading coefficient
    return f.numerator().monic()

# 5) COLLAPSE ORBITS, picking the lex‐min coefficient tuple as canonical rep
reps = []
seen = set()
for q in all_q:
    if q in seen:
        continue
    # compute entire orbit under PGL₂
    orb = {mobius(q, M) for M in PGL2}
    # choose the smallest in lex order on coefficient‐vectors
    rep = min(orb, key=lambda p: tuple(p.coefficients(sparse=False)))
    reps.append(rep)
    seen.update(orb)

print(f"After modding out by PGL₂, you get {len(reps)} representatives Q := {{q₁,…,qₙ}}.")
# `reps` is now exactly the list of q(x) up to isomorphism.
print(reps)

# Qrep = []
# seen = set()
# for qpoly in Qcands:
#     if qpoly in seen:
#         continue
#     orbit = {mobius(qpoly, M) for M in Mobs}
#     seen.update(orbit)
#     Qrep.append(qpoly)
# print(f"{len(Qrep)} representatives after modding out involutions")

# # 5) For each q ∈ Qrep, enumerate RHS p(x) polys of deg ≤ 2g+2 = 8
# max_dp = 2*g + 2        # = 8
# Dpolys = list(R.polynomials(max_degree=max_dp))
# Vq = {}
# for qpoly in Qrep:
#     # find subgroup G_q fixing qpoly (of our two involutions)
#     Gq = [M for M in Mobs if mobius(qpoly, M) == qpoly]
#     plist = []
#     for p in Dpolys:
#         forms = set()
#         for r in R.polynomials(max_degree=d):
#             f = p + r**2 + qpoly*r
#             if f == 0:
#                 # skip the zero polynomial — it doesn't define a valid curve
#                 continue
#             forms.add(f.monic())

#         # mod out by Gq
#         seen_p = set()
#         reps_p = []
#         for fp in forms:
#             if fp in seen_p:
#                 continue
#             orb = { mobius(fp, M) for M in Gq }
#             seen_p.update(orb)
#             reps_p.append(fp)
#         plist.extend(reps_p)
#     Vq[qpoly] = reps_p

# # 6) Nonsingularity check in char=2:
# #    A hyperelliptic y^2+q y = p is smooth iff
# #      gcd(q, p'² + (q')²·p) == 1
# from sage.rings.polynomial.polynomial_ring import gcd
# final_curves = {}
# for qpoly, plist in Vq.items():
#     good = []
#     qd = qpoly.derivative()
#     for p in plist:
#         expr = p.derivative()**2 + qd**2 * p
#         if gcd(qpoly, expr) == 1:
#             good.append(p)
#     final_curves[qpoly] = good

# total = sum(len(v) for v in final_curves.values())
# print(f"Found {total} genus-{g} nonsingular curves of the form y²+q(x)y=p(x) over GF(2^{n})")

